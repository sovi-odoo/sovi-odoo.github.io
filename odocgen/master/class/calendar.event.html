<!doctype html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>calendar.event - odocgen</title><link rel="stylesheet" href="class.css" /></head><body><h1>calendar.event</h1><p>Inherited in: odoo/addons/microsoft_calendar/models/calendar.py<br/>Inherited in: odoo/addons/hr_recruitment/models/calendar.py<br/>Inherited in: odoo/addons/google_calendar/models/calendar.py<br/>Inherited in: odoo/addons/crm/models/calendar.py<br/>Inherited in: odoo/addons/calendar_sms/models/calendar_event.py<br/>Inherited in: odoo/addons/calendar/models/calendar_event.py<br/></p><hr/><h2>Inherited: odoo/addons/microsoft_calendar/models/calendar.py</h2><h3>Fields</h3><details><summary id="f-microsoft_recurrence_master_id">microsoft_recurrence_master_id <span class="position">@ line 41</span></summary><pre>microsoft_recurrence_master_id = fields.Char('Microsoft Recurrence Master Id')</pre></details><h3>Methods</h3><details><summary id="m-_cancel_microsoft">_cancel_microsoft(self) <span class="position">@ line 655</span></summary><pre>Cancel an Microsoft event.
There are 2 cases:
1) the organizer is an Odoo user: he's the only one able to delete the Odoo event. Attendees can just decline.
2) the organizer is NOT an Odoo user: any attendee should remove the Odoo event.</pre></details><details><summary id="m-_check_microsoft_sync_status">_check_microsoft_sync_status(self) <span class="position">@ line 65</span></summary><pre>Returns True if synchronization with Outlook Calendar is active and False otherwise.
The 'microsoft_synchronization_stopped' variable needs to be 'False' and Outlook account must be connected.</pre></details><details><summary id="m-_check_organizer_validation">_check_organizer_validation(self, sender_user, partner_included) <span class="position">@ line 103</span></summary><pre>Check if the proposed event organizer can be set accordingly.</pre></details><details><summary id="m-_check_recurrence_overlapping">_check_recurrence_overlapping(self, new_start) <span class="position">@ line 118</span></summary><pre>Outlook does not allow to modify time fields of an event if this event crosses
or overlaps the recurrence. In this case a 400 error with the Outlook code "ErrorOccurrenceCrossingBoundary"
is returned. That means that the update violates the following Outlook restriction on recurrence exceptions:
an occurrence cannot be moved to or before the day of the previous occurrence, and cannot be moved to or after
the day of the following occurrence.
For example: E1 E2 E3 E4 cannot becomes E1 E3 E2 E4</pre></details><ul id="m-_ensure_attendees_have_email"><li>_ensure_attendees_have_email(self) <span class="position">@ line 617</span></li></ul><details><summary id="m-_forbid_recurrence_creation">_forbid_recurrence_creation(self) <span class="position">@ line 165</span></summary><pre>Suggest user to update recurrences in Outlook due to the Outlook Calendar spam limitation.</pre></details><details><summary id="m-_forbid_recurrence_update">_forbid_recurrence_update(self) <span class="position">@ line 152</span></summary><pre>Suggest user to update recurrences in Outlook due to the Outlook Calendar spam limitation.</pre></details><ul id="m-_get_attendee_status_o2m"><li>_get_attendee_status_o2m(self, attendee) <span class="position">@ line 484</span></li></ul><details><summary id="m-_get_event_user_m">_get_event_user_m(self, user_id) <span class="position">@ line 671</span></summary><pre>Get the user who will send the request to Microsoft (organizer if synchronized and current user otherwise).</pre></details><ul id="m-_get_microsoft_sync_domain"><li>_get_microsoft_sync_domain(self) <span class="position">@ line 278</span></li></ul><ul id="m-_get_organizer"><li>_get_organizer(self) <span class="position">@ line 43</span></li></ul><details><summary id="m-_is_matching_timeslot">_is_matching_timeslot(self, start, stop, allday) <span class="position">@ line 139</span></summary><pre>Check if an event matches with the provided timeslot</pre></details><ul id="m-_microsoft_values"><li>_microsoft_values(self, fields_to_sync, initial_values) <span class="position">@ line 489</span></li></ul><ul id="m-_microsoft_values_occurence"><li>_microsoft_values_occurence(self, initial_values) <span class="position">@ line 638</span></li></ul><details><summary id="m-_recreate_event_different_organizer">_recreate_event_different_organizer(self, values, sender_user) <span class="position">@ line 234</span></summary><pre>Copy current event values, delete it and recreate it with the new organizer user.</pre></details><details><summary id="m-_skip_send_mail_status_update">_skip_send_mail_status_update(self) <span class="position">@ line 73</span></summary><pre>If microsoft calendar is not syncing, don't send a mail.</pre></details><details><summary id="m-_update_attendee_status">_update_attendee_status(self, attendee_ids) <span class="position">@ line 257</span></summary><pre>Merge current status from 'attendees_ids' with new attendees values for avoiding their info loss in write().
Create a dict getting the state of each attendee received from 'attendee_ids' variable and then update their state.
:param attendee_ids: List of attendee commands carrying a dict with 'partner_id' and 'state' keys in its third position.</pre></details><ul id="m-action_mass_archive"><li>action_mass_archive(self, recurrence_update_setting) <span class="position">@ line 271</span></li></ul><ul id="m-unlink"><li>unlink(self) <span class="position">@ line 224</span></li></ul><ul id="m-write"><li>write(self, values) <span class="position">@ line 171</span></li></ul><h2>Inherited: odoo/addons/hr_recruitment/models/calendar.py</h2><h3>Fields</h3><details><summary id="f-applicant_id">applicant_id <span class="position">@ line 62</span></summary><pre>applicant_id = fields.Many2one('hr.applicant', string="Applicant", index='btree_not_null', ondelete='set null')</pre></details><h3>Methods</h3><ul id="m-_compute_is_highlighted"><li>_compute_is_highlighted(self) <span class="position">@ line 54</span></li></ul><h2>Inherited: odoo/addons/google_calendar/models/calendar.py</h2><h3>Fields</h3><details><summary id="f-MEET_ROUTE">MEET_ROUTE <span class="position">@ line 18</span></summary><pre>MEET_ROUTE = 'meet.google.com'</pre></details><details><summary id="f-google_id">google_id <span class="position">@ line 20</span></summary><pre>google_id = fields.Char(
        'Google Calendar Event Id', compute='_compute_google_id', store=True, readonly=False)</pre></details><details><summary id="f-guests_readonly">guests_readonly <span class="position">@ line 22</span></summary><pre>guests_readonly = fields.Boolean(
        'Guests Event Modification Permission', default=False)</pre></details><details><summary id="f-videocall_source">videocall_source <span class="position">@ line 24</span></summary><pre>videocall_source = fields.Selection(selection_add=[('google_meet', 'Google Meet')], ondelete={'google_meet': 'set discuss'})</pre></details><h3>Methods</h3><ul id="m-_cancel"><li>_cancel(self) <span class="position">@ line 357</span></li></ul><ul id="m-_check_modify_event_permission"><li>_check_modify_event_permission(self, values) <span class="position">@ line 101</span></li></ul><ul id="m-_get_event_user"><li>_get_event_user(self) <span class="position">@ line 368</span></li></ul><ul id="m-_get_sync_domain"><li>_get_sync_domain(self) <span class="position">@ line 117</span></li></ul><ul id="m-_google_values"><li>_google_values(self) <span class="position">@ line 287</span></li></ul><details><summary id="m-_skip_send_mail_status_update">_skip_send_mail_status_update(self) <span class="position">@ line 110</span></summary><pre>If a google calendar is not syncing with the user, don't send a mail.</pre></details><details><summary id="m-action_mass_archive">action_mass_archive(self, recurrence_update_setting) <span class="position">@ line 275</span></summary><pre>Delete recurrence in Odoo if in 'all_events' or in 'future_events' edge case, triggering one mail.</pre></details><ul id="m-write"><li>write(self, values) <span class="position">@ line 89</span></li></ul><h2>Inherited: odoo/addons/crm/models/calendar.py</h2><h3>Fields</h3><details><summary id="f-opportunity_id">opportunity_id <span class="position">@ line 26</span></summary><pre>opportunity_id = fields.Many2one(
        'crm.lead', 'Opportunity', domain="[('type', '=', 'opportunity')]",
        index=True, ondelete='set null')</pre></details><h3>Methods</h3><ul id="m-_compute_is_highlighted"><li>_compute_is_highlighted(self) <span class="position">@ line 30</span></li></ul><details><summary id="m-_is_crm_lead">_is_crm_lead(self, defaults, ctx) <span class="position">@ line 46</span></summary><pre>This method checks if the concerned model is a CRM lead.
The information is not always in the defaults values,
this is why it is necessary to check the context too.</pre></details><h2>Inherited: odoo/addons/calendar_sms/models/calendar_event.py</h2><h3>Methods</h3><details><summary id="m-_do_sms_reminder">_do_sms_reminder(self, alarms) <span class="position">@ line 10</span></summary><pre>Send an SMS text reminder to attendees that haven't declined the event</pre></details><ul id="m-_get_trigger_alarm_types"><li>_get_trigger_alarm_types(self) <span class="position">@ line 44</span></li></ul><ul id="m-action_send_sms"><li>action_send_sms(self) <span class="position">@ line 27</span></li></ul><h2>Inherited: odoo/addons/calendar/models/calendar_event.py</h2><h3>Fields</h3><details><summary id="f-DISCUSS_ROUTE">DISCUSS_ROUTE <span class="position">@ line 74</span></summary><pre>DISCUSS_ROUTE = 'calendar/join_videocall'</pre></details><details><summary id="f-accepted_count">accepted_count <span class="position">@ line 248</span></summary><pre>accepted_count = fields.Integer(compute='_compute_attendees_count')</pre></details><details><summary id="f-access_token">access_token <span class="position">@ line 130</span></summary><pre>access_token = fields.Char('Invitation Token', store=True, copy=False, index=True)</pre></details><details><summary id="f-active">active <span class="position">@ line 152</span></summary><pre>active = fields.Boolean(
        'Active', default=True,
        tracking=True,
        help="If the active field is set to false, it will allow you to hide the event alarm information without removing it.")</pre></details><details><summary id="f-activity_ids">activity_ids <span class="position">@ line 182</span></summary><pre>activity_ids = fields.One2many('mail.activity', 'calendar_event_id', string='Activities')</pre></details><details><summary id="f-alarm_ids">alarm_ids <span class="position">@ line 194</span></summary><pre>alarm_ids = fields.Many2many(
        'calendar.alarm', 'calendar_alarm_calendar_event_rel',
        string='Reminders', ondelete="restrict",
        help="Notifications sent to all attendees to remind of the meeting.")</pre></details><details><summary id="f-allday">allday <span class="position">@ line 167</span></summary><pre>allday = fields.Boolean('All Day', default=False)</pre></details><details><summary id="f-attendee_ids">attendee_ids <span class="position">@ line 184</span></summary><pre>attendee_ids = fields.One2many(
        'calendar.attendee', 'event_id', 'Participant')</pre></details><details><summary id="f-attendees_count">attendees_count <span class="position">@ line 247</span></summary><pre>attendees_count = fields.Integer(compute='_compute_attendees_count')</pre></details><details><summary id="f-awaiting_count">awaiting_count <span class="position">@ line 251</span></summary><pre>awaiting_count = fields.Integer(compute="_compute_attendees_count")</pre></details><details><summary id="f-byday">byday <span class="position">@ line 243</span></summary><pre>byday = fields.Selection(BYDAY_SELECTION, string="By day", compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-categ_ids">categ_ids <span class="position">@ line 156</span></summary><pre>categ_ids = fields.Many2many(
        'calendar.event.type', 'meeting_category_rel', 'event_id', 'type_id', 'Tags')</pre></details><details><summary id="f-count">count <span class="position">@ line 230</span></summary><pre>count = fields.Integer(
        string='Number of Repetitions', help="Repeat x times", compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-current_attendee">current_attendee <span class="position">@ line 186</span></summary><pre>current_attendee = fields.Many2one("calendar.attendee", compute="_compute_current_attendee", search="_search_current_attendee")</pre></details><details><summary id="f-current_status">current_status <span class="position">@ line 187</span></summary><pre>current_status = fields.Selection(string="Attending?", related="current_attendee.state", readonly=False)</pre></details><details><summary id="f-day">day <span class="position">@ line 241</span></summary><pre>day = fields.Integer('Date of month', compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-declined_count">declined_count <span class="position">@ line 249</span></summary><pre>declined_count = fields.Integer(compute='_compute_attendees_count')</pre></details><details><summary id="f-description">description <span class="position">@ line 124</span></summary><pre>description = fields.Html('Description')</pre></details><details><summary id="f-display_description">display_description <span class="position">@ line 246</span></summary><pre>display_description = fields.Boolean(compute='_compute_display_description')</pre></details><details><summary id="f-display_time">display_time <span class="position">@ line 166</span></summary><pre>display_time = fields.Char('Event Time', compute='_compute_display_time')</pre></details><details><summary id="f-duration">duration <span class="position">@ line 174</span></summary><pre>duration = fields.Float('Duration', compute='_compute_duration', store=True, readonly=False)</pre></details><details><summary id="f-end_type">end_type <span class="position">@ line 224</span></summary><pre>end_type = fields.Selection(
        END_TYPE_SELECTION, string='Recurrence Termination',
        compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-event_tz">event_tz <span class="position">@ line 222</span></summary><pre>event_tz = fields.Selection(
        _tz_get, string='Timezone', compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-follow_recurrence">follow_recurrence <span class="position">@ line 202</span></summary><pre>follow_recurrence = fields.Boolean(default=False)</pre></details><details><summary id="f-fri">fri <span class="position">@ line 236</span></summary><pre>fri = fields.Boolean(compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-interval">interval <span class="position">@ line 227</span></summary><pre>interval = fields.Integer(
        string='Repeat On', compute='_compute_recurrence', readonly=False,
        help="Repeat every (Days/Week/Month/Year)")</pre></details><details><summary id="f-invalid_email_partner_ids">invalid_email_partner_ids <span class="position">@ line 192</span></summary><pre>invalid_email_partner_ids = fields.Many2many('res.partner', compute='_compute_invalid_email_partner_ids')</pre></details><details><summary id="f-is_highlighted">is_highlighted <span class="position">@ line 146</span></summary><pre>is_highlighted = fields.Boolean(
        compute='_compute_is_highlighted', string='Is the Event Highlighted')</pre></details><details><summary id="f-is_organizer_alone">is_organizer_alone <span class="position">@ line 148</span></summary><pre>is_organizer_alone = fields.Boolean(compute='_compute_is_organizer_alone', string="Is the Organizer Alone",
        help="""Check if the organizer is alone in the event, i.e. if the organizer is the only one that hasn't declined
        the event (only if the organizer is not the only attendee)""")</pre></details><details><summary id="f-location">location <span class="position">@ line 128</span></summary><pre>location = fields.Char('Location', tracking=True)</pre></details><details><summary id="f-mon">mon <span class="position">@ line 232</span></summary><pre>mon = fields.Boolean(compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-month_by">month_by <span class="position">@ line 239</span></summary><pre>month_by = fields.Selection(
        MONTH_BY_SELECTION, string='Option', compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-name">name <span class="position">@ line 123</span></summary><pre>name = fields.Char('Meeting Subject', required=True)</pre></details><details><summary id="f-partner_id">partner_id <span class="position">@ line 126</span></summary><pre>partner_id = fields.Many2one(
        'res.partner', string='Scheduled by', related='user_id.partner_id', readonly=True)</pre></details><details><summary id="f-partner_ids">partner_ids <span class="position">@ line 189</span></summary><pre>partner_ids = fields.Many2many(
        'res.partner', 'calendar_event_res_partner_rel',
        string='Attendees', default=_default_partners)</pre></details><details><summary id="f-privacy">privacy <span class="position">@ line 134</span></summary><pre>privacy = fields.Selection(
        [('public', 'Public'),
         ('private', 'Private'),
         ('confidential', 'Only internal users')], 'Privacy',
        help="People to whom this event will be visible.")</pre></details><details><summary id="f-recurrence_id">recurrence_id <span class="position">@ line 200</span></summary><pre>recurrence_id = fields.Many2one(
        'calendar.recurrence', string="Recurrence Rule")</pre></details><details><summary id="f-recurrence_update">recurrence_update <span class="position">@ line 203</span></summary><pre>recurrence_update = fields.Selection([
        ('self_only', "This event"),
        ('future_events', "This and following events"),
        ('all_events', "All events"),
    ], store=False, copy=False, default='self_only',
       help="Choose what to do with other events in the recurrence. Updating All Events is not allowed when dates or time is modified")</pre></details><details><summary id="f-recurrency">recurrency <span class="position">@ line 199</span></summary><pre>recurrency = fields.Boolean('Recurrent')</pre></details><details><summary id="f-res_id">res_id <span class="position">@ line 176</span></summary><pre>res_id = fields.Many2oneReference('Document ID', model_field='res_model')</pre></details><details><summary id="f-res_model">res_model <span class="position">@ line 178</span></summary><pre>res_model = fields.Char(
        'Document Model Name', related='res_model_id.model', readonly=True, store=True)</pre></details><details><summary id="f-res_model_id">res_model_id <span class="position">@ line 177</span></summary><pre>res_model_id = fields.Many2one('ir.model', 'Document Model', ondelete='cascade')</pre></details><details><summary id="f-res_model_name">res_model_name <span class="position">@ line 180</span></summary><pre>res_model_name = fields.Char(related='res_model_id.name')</pre></details><details><summary id="f-rrule">rrule <span class="position">@ line 214</span></summary><pre>rrule = fields.Char('Recurrent Rule', compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-rrule_type">rrule_type <span class="position">@ line 219</span></summary><pre>rrule_type = fields.Selection(RRULE_TYPE_SELECTION, string='Recurrence',
                                  help="Let the event automatically repeat at that interval",
                                  compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-rrule_type_ui">rrule_type_ui <span class="position">@ line 215</span></summary><pre>rrule_type_ui = fields.Selection(RRULE_TYPE_SELECTION_UI, string='Repeat',
                                     compute="_compute_rrule_type_ui",
                                     readonly=False,
                                     help="Let the event automatically repeat at that interval")</pre></details><details><summary id="f-sat">sat <span class="position">@ line 237</span></summary><pre>sat = fields.Boolean(compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-should_show_status">should_show_status <span class="position">@ line 188</span></summary><pre>should_show_status = fields.Boolean(compute="_compute_should_show_status")</pre></details><details><summary id="f-show_as">show_as <span class="position">@ line 139</span></summary><pre>show_as = fields.Selection(
        [('free', 'Available'),
         ('busy', 'Busy')], 'Show as', default='busy', required=True,
        help="If the time is shown as 'busy', this event will be visible to other people with either the full \
        information or simply 'busy' written depending on its privacy. Use this option to let other people know \
        that you are unavailable during that period of time. \n If the event is shown as 'free', other users know \
        that you are available during that period of time.")</pre></details><details><summary id="f-start">start <span class="position">@ line 159</span></summary><pre>start = fields.Datetime(
        'Start', required=True, tracking=True, default=_default_start,
        help="Start date of an event, without time for full days events")</pre></details><details><summary id="f-start_date">start_date <span class="position">@ line 168</span></summary><pre>start_date = fields.Date(
        'Start Date', store=True, tracking=True,
        compute='_compute_dates', inverse='_inverse_dates')</pre></details><details><summary id="f-stop">stop <span class="position">@ line 162</span></summary><pre>stop = fields.Datetime(
        'Stop', required=True, tracking=True, default=_default_stop,
        compute='_compute_stop', readonly=False, store=True,
        help="Stop date of an event, without time for full days events")</pre></details><details><summary id="f-stop_date">stop_date <span class="position">@ line 171</span></summary><pre>stop_date = fields.Date(
        'End Date', store=True, tracking=True,
        compute='_compute_dates', inverse='_inverse_dates')</pre></details><details><summary id="f-sun">sun <span class="position">@ line 238</span></summary><pre>sun = fields.Boolean(compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-tentative_count">tentative_count <span class="position">@ line 250</span></summary><pre>tentative_count = fields.Integer(compute='_compute_attendees_count')</pre></details><details><summary id="f-thu">thu <span class="position">@ line 235</span></summary><pre>thu = fields.Boolean(compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-tue">tue <span class="position">@ line 233</span></summary><pre>tue = fields.Boolean(compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-until">until <span class="position">@ line 244</span></summary><pre>until = fields.Date(compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-user_can_edit">user_can_edit <span class="position">@ line 252</span></summary><pre>user_can_edit = fields.Boolean(compute='_compute_user_can_edit')</pre></details><details><summary id="f-user_id">user_id <span class="position">@ line 125</span></summary><pre>user_id = fields.Many2one('res.users', 'Organizer', default=lambda self: self.env.user)</pre></details><details><summary id="f-videocall_channel_id">videocall_channel_id <span class="position">@ line 132</span></summary><pre>videocall_channel_id = fields.Many2one('discuss.channel', 'Discuss Channel')</pre></details><details><summary id="f-videocall_location">videocall_location <span class="position">@ line 129</span></summary><pre>videocall_location = fields.Char('Meeting URL', compute='_compute_videocall_location', store=True, copy=True)</pre></details><details><summary id="f-videocall_source">videocall_source <span class="position">@ line 131</span></summary><pre>videocall_source = fields.Selection([('discuss', 'Discuss'), ('custom', 'Custom')], compute='_compute_videocall_source')</pre></details><details><summary id="f-wed">wed <span class="position">@ line 234</span></summary><pre>wed = fields.Boolean(compute='_compute_recurrence', readonly=False)</pre></details><details><summary id="f-weekday">weekday <span class="position">@ line 242</span></summary><pre>weekday = fields.Selection(WEEKDAY_SELECTION, compute='_compute_recurrence', readonly=False)</pre></details><h3>Methods</h3><details><summary id="m-_apply_recurrence_values">_apply_recurrence_values(self, values, future) <span class="position">@ line 1072</span></summary><pre>Apply the new recurrence rules in `values`. Create a recurrence if it does not exist
and create all missing events according to the rrule.
If the changes are applied to future
events only, a new recurrence is created with the updated rrule.

:param values: new recurrence values to apply
:param future: rrule values are applied to future events only if True.
Rrule changes are applied to all events in the recurrence otherwise.
(ignored if no recurrence exists yet).
:return: events detached from the recurrence</pre></details><details><summary id="m-_attendees_values">_attendees_values(self, partner_commands) <span class="position">@ line 818</span></summary><pre>:param partner_commands: ORM commands for partner_id field (0 and 1 commands not supported)
:return: associated attendee_ids ORM commands</pre></details><details><summary id="m-_break_recurrence">_break_recurrence(self, future) <span class="position">@ line 1140</span></summary><pre>Breaks the event's recurrence.
Stop the recurrence at the current event if `future` is True, leaving past events in the recurrence.
If `future` is False, all events in the recurrence are detached and the recurrence itself is unlinked.
:return: detached events excluding the current events</pre></details><details><summary id="m-_check_calendar_privacy_write_permissions">_check_calendar_privacy_write_permissions(self) <span class="position">@ line 730</span></summary><pre>Checks if current user can write on the events, raising UserError when the event is private.
We need to manually call the default Access Error because we can't add an access rule for checking
the calendar defaut privacy of an user from a 'calendar.event' record, since it is a res.users field.
Otherwise we would have to create a new computed field on that model, which we don't want.</pre></details><details><summary id="m-_check_private_event_conditions">_check_private_event_conditions(self) <span class="position">@ line 741</span></summary><pre>Checks if the event is private, returning True if the conditions match and False otherwise.</pre></details><ul id="m-_compute_display_time"><li>_compute_display_time(self) <span class="position">@ line 326</span></li></ul><ul id="m-_compute_field_value"><li>_compute_field_value(self, field) <span class="position">@ line 590</span></li></ul><ul id="m-_compute_is_highlighted"><li>_compute_is_highlighted(self) <span class="position">@ line 300</span></li></ul><ul id="m-_create_videocall_channel"><li>_create_videocall_channel(self) <span class="position">@ line 858</span></li></ul><ul id="m-_create_videocall_channel_id"><li>_create_videocall_channel_id(self, name, partner_ids) <span class="position">@ line 871</span></li></ul><ul id="m-_fetch_query"><li>_fetch_query(self, query, fields) <span class="position">@ line 595</span></li></ul><details><summary id="m-_get_attendee_emails">_get_attendee_emails(self) <span class="position">@ line 984</span></summary><pre>Get comma-separated attendee email addresses.</pre></details><details><summary id="m-_get_customer_description">_get_customer_description(self) <span class="position">@ line 1421</span></summary><pre>:return (str): The description to include in calendar exports</pre></details><details><summary id="m-_get_customer_summary">_get_customer_summary(self) <span class="position">@ line 1425</span></summary><pre>:return (str): The summary to include in calendar exports</pre></details><details><summary id="m-_get_duration">_get_duration(self, start, stop) <span class="position">@ line 1475</span></summary><pre>Get the duration value between the 2 given dates.</pre></details><details><summary id="m-_get_ics_file">_get_ics_file(self) <span class="position">@ line 1357</span></summary><pre>Returns iCalendar file for the event invitation.
:returns a dict of .ics file content for each meeting</pre></details><ul id="m-_get_mail_tz"><li>_get_mail_tz(self) <span class="position">@ line 989</span></li></ul><ul id="m-_get_recurrence_params"><li>_get_recurrence_params(self) <span class="position">@ line 1097</span></li></ul><details><summary id="m-_get_start_date">_get_start_date(self) <span class="position">@ line 1332</span></summary><pre>Return the event starting date in the event's timezone.
If no starting time is assigned (yet), return today as default
:return: date</pre></details><details><summary id="m-_get_time_update_dict">_get_time_update_dict(self, base_event, time_values) <span class="position">@ line 1159</span></summary><pre>Return the update dictionary for shifting the base_event's time to the new date.</pre></details><ul id="m-_get_trigger_alarm_types"><li>_get_trigger_alarm_types(self) <span class="position">@ line 1021</span></li></ul><details><summary id="m-_get_updated_recurrence_values">_get_updated_recurrence_values(self, new_start_date) <span class="position">@ line 1206</span></summary><pre>Copy values from current recurrence and update the start date weekday.</pre></details><details><summary id="m-_inverse_dates">_inverse_dates(self) <span class="position">@ line 381</span></summary><pre>This method is used to set the start and stop values of all day events.
The calendar view needs date_start and date_stop values to display correctly the allday events across
several days. As the user edit the {start,stop}_date fields when allday is true,
this inverse method is needed to update the  start/stop value and have a relevant calendar view.</pre></details><ul id="m-_range"><li>_range(self) <span class="position">@ line 1346</span></li></ul><details><summary id="m-_reset_attendees_status">_reset_attendees_status(self) <span class="position">@ line 1324</span></summary><pre>Reset attendees status to pending and accept event for current user.</pre></details><details><summary id="m-_rewrite_recurrence">_rewrite_recurrence(self, values, time_values, recurrence_values) <span class="position">@ line 1253</span></summary><pre>Delete the current recurrence, reactivate base event and apply updated recurrence values.</pre></details><ul id="m-_search_current_attendee"><li>_search_current_attendee(self, operator, value) <span class="position">@ line 265</span></li></ul><details><summary id="m-_set_discuss_videocall_location">_set_discuss_videocall_location(self) <span class="position">@ line 492</span></summary><pre>This method sets the videocall_location to a discuss route.
If no access_token exists for this event, we create one.
Note that recurring events will have different access_tokens.
This is done by design to prevent users not being able to join a discuss meeting because the base event of the recurrency was deleted.</pre></details><details><summary id="m-_setup_alarms">_setup_alarms(self) <span class="position">@ line 1024</span></summary><pre>Schedule cron triggers for future events</pre></details><details><summary id="m-_skip_send_mail_status_update">_skip_send_mail_status_update(self) <span class="position">@ line 980</span></summary><pre>Overridable getter to identify whether to send invitation/cancelation emails.</pre></details><details><summary id="m-_split_recurrence">_split_recurrence(self, time_values) <span class="position">@ line 1120</span></summary><pre>Apply time changes to events and update the recurrence accordingly.

:return: detached events</pre></details><ul id="m-_sync_activities"><li>_sync_activities(self, fields) <span class="position">@ line 993</span></li></ul><details><summary id="m-_update_future_events">_update_future_events(self, values, time_values, recurrence_values) <span class="position">@ line 1213</span></summary><pre>Trim the current recurrence detaching the occurrences after current event,
deactivate the detached events except for the updated event and apply recurrence values.</pre></details><details><summary id="m-action_join_meeting">action_join_meeting(self, partner_id) <span class="position">@ line 938</span></summary><pre>Method used when an existing user wants to join</pre></details><ul id="m-action_join_video_call"><li>action_join_video_call(self) <span class="position">@ line 931</span></li></ul><details><summary id="m-action_mass_archive">action_mass_archive(self, recurrence_update_setting) <span class="position">@ line 956</span></summary><pre>The aim of this action purpose is to be called from sync calendar module when mass deletion is not possible.</pre></details><ul id="m-action_mass_deletion"><li>action_mass_deletion(self, recurrence_update_setting) <span class="position">@ line 946</span></li></ul><ul id="m-action_open_calendar_event"><li>action_open_calendar_event(self) <span class="position">@ line 893</span></li></ul><ul id="m-action_open_composer"><li>action_open_composer(self) <span class="position">@ line 906</span></li></ul><ul id="m-action_sendmail"><li>action_sendmail(self) <span class="position">@ line 898</span></li></ul><ul id="m-change_attendee_status"><li>change_attendee_status(self, status, recurrence_update_setting) <span class="position">@ line 1297</span></li></ul><ul id="m-clear_videocall_location"><li>clear_videocall_location(self) <span class="position">@ line 890</span></li></ul><details><summary id="m-copy">copy(self, default) <span class="position">@ line 797</span></summary><pre>When an event is copied, the attendees should be recreated to avoid sharing the same attendee records
between copies</pre></details><ul id="m-find_partner_customer"><li>find_partner_customer(self) <span class="position">@ line 1312</span></li></ul><details><summary id="m-get_display_time_tz">get_display_time_tz(self, tz) <span class="position">@ line 1350</span></summary><pre>get the display_time of the meeting, forcing the timezone. This method is called from email template, to not use sudo().</pre></details><ul id="m-get_next_alarm_date"><li>get_next_alarm_date(self, events_by_alarm) <span class="position">@ line 1046</span></li></ul><ul id="m-set_discuss_videocall_location"><li>set_discuss_videocall_location(self) <span class="position">@ line 886</span></li></ul><ul id="m-unlink"><li>unlink(self) <span class="position">@ line 773</span></li></ul><ul id="m-write"><li>write(self, values) <span class="position">@ line 621</span></li></ul><script src="class.js"></script></body></html>
