<!doctype html><html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>calendar.recurrence - odocgen</title><link rel="stylesheet" href="class.css" /></head><body><h1>calendar.recurrence</h1><p>Originally defined in: odoo/addons/calendar/models/calendar_recurrence.py</p><p>Inherited in: odoo/addons/microsoft_calendar/models/calendar_recurrence_rule.py<br/>Inherited in: odoo/addons/google_calendar/models/calendar_recurrence_rule.py<br/></p><hr/><h2>Original: odoo/addons/calendar/models/calendar_recurrence.py</h2><h3>Fields</h3><details><summary id="f-base_event_id">base_event_id <span class="position">@ line 98</span></summary><pre>base_event_id = fields.Many2one(
        'calendar.event', ondelete='set null', copy=False)</pre></details><details><summary id="f-byday">byday <span class="position">@ line 120</span></summary><pre>byday = fields.Selection(BYDAY_SELECTION, string='By day')</pre></details><details><summary id="f-calendar_event_ids">calendar_event_ids <span class="position">@ line 100</span></summary><pre>calendar_event_ids = fields.One2many('calendar.event', 'recurrence_id')</pre></details><details><summary id="f-count">count <span class="position">@ line 109</span></summary><pre>count = fields.Integer(default=1)</pre></details><details><summary id="f-day">day <span class="position">@ line 118</span></summary><pre>day = fields.Integer(default=1)</pre></details><details><summary id="f-dtstart">dtstart <span class="position">@ line 105</span></summary><pre>dtstart = fields.Datetime(compute='_compute_dtstart')</pre></details><details><summary id="f-end_type">end_type <span class="position">@ line 107</span></summary><pre>end_type = fields.Selection(END_TYPE_SELECTION, default='count')</pre></details><details><summary id="f-event_tz">event_tz <span class="position">@ line 101</span></summary><pre>event_tz = fields.Selection(
        _tz_get, string='Timezone',
        default=lambda self: self.env.context.get('tz') or self.env.user.tz)</pre></details><details><summary id="f-fri">fri <span class="position">@ line 114</span></summary><pre>fri = fields.Boolean()</pre></details><details><summary id="f-interval">interval <span class="position">@ line 108</span></summary><pre>interval = fields.Integer(default=1)</pre></details><details><summary id="f-mon">mon <span class="position">@ line 110</span></summary><pre>mon = fields.Boolean()</pre></details><details><summary id="f-month_by">month_by <span class="position">@ line 117</span></summary><pre>month_by = fields.Selection(MONTH_BY_SELECTION, default='date')</pre></details><details><summary id="f-name">name <span class="position">@ line 97</span></summary><pre>name = fields.Char(compute='_compute_name', store=True)</pre></details><details><summary id="f-rrule">rrule <span class="position">@ line 104</span></summary><pre>rrule = fields.Char(compute='_compute_rrule', inverse='_inverse_rrule', store=True)</pre></details><details><summary id="f-rrule_type">rrule_type <span class="position">@ line 106</span></summary><pre>rrule_type = fields.Selection(RRULE_TYPE_SELECTION, default='weekly')</pre></details><details><summary id="f-sat">sat <span class="position">@ line 115</span></summary><pre>sat = fields.Boolean()</pre></details><details><summary id="f-sun">sun <span class="position">@ line 116</span></summary><pre>sun = fields.Boolean()</pre></details><details><summary id="f-thu">thu <span class="position">@ line 113</span></summary><pre>thu = fields.Boolean()</pre></details><details><summary id="f-trigger_id">trigger_id <span class="position">@ line 122</span></summary><pre>trigger_id = fields.Many2one('ir.cron.trigger')</pre></details><details><summary id="f-tue">tue <span class="position">@ line 111</span></summary><pre>tue = fields.Boolean()</pre></details><details><summary id="f-until">until <span class="position">@ line 121</span></summary><pre>until = fields.Date('Repeat Until')</pre></details><details><summary id="f-wed">wed <span class="position">@ line 112</span></summary><pre>wed = fields.Boolean()</pre></details><details><summary id="f-weekday">weekday <span class="position">@ line 119</span></summary><pre>weekday = fields.Selection(WEEKDAY_SELECTION, string='Weekday')</pre></details><h3>Methods</h3><details><summary id="m-_apply_recurrence">_apply_recurrence(self, specific_values_creation, no_send_edit, generic_values_creation) <span class="position">@ line 242</span></summary><pre>Create missing events in the recurrence and detach events which no longer
follow the recurrence rules.
:return: detached events</pre></details><ul id="m-_get_daily_recurrence_name"><li>_get_daily_recurrence_name(self) <span class="position">@ line 134</span></li></ul><ul id="m-_get_events_from"><li>_get_events_from(self, dtstart) <span class="position">@ line 540</span></li></ul><ul id="m-_get_first_event"><li>_get_first_event(self, include_outliers) <span class="position">@ line 459</span></li></ul><ul id="m-_get_lang_week_start"><li>_get_lang_week_start(self) <span class="position">@ line 434</span></li></ul><ul id="m-_get_monthly_recurrence_name"><li>_get_monthly_recurrence_name(self) <span class="position">@ line 158</span></li></ul><details><summary id="m-_get_occurrences">_get_occurrences(self, dtstart) <span class="position">@ line 505</span></summary><pre>Get ocurrences of the rrule
:param dtstart: start of the recurrence
:return: iterable of datetimes</pre></details><ul id="m-_get_outliers"><li>_get_outliers(self) <span class="position">@ line 467</span></li></ul><ul id="m-_get_ranges"><li>_get_ranges(self, start, event_duration) <span class="position">@ line 498</span></li></ul><ul id="m-_get_rrule"><li>_get_rrule(self, dtstart) <span class="position">@ line 569</span></li></ul><ul id="m-_get_start_of_period"><li>_get_start_of_period(self, dt) <span class="position">@ line 439</span></li></ul><ul id="m-_get_timezone"><li>_get_timezone(self) <span class="position">@ line 502</span></li></ul><details><summary id="m-_get_week_days">_get_week_days(self) <span class="position">@ line 546</span></summary><pre>:return: tuple of rrule weekdays for this recurrence.</pre></details><ul id="m-_get_weekly_recurrence_name"><li>_get_weekly_recurrence_name(self) <span class="position">@ line 141</span></li></ul><ul id="m-_get_yearly_recurrence_name"><li>_get_yearly_recurrence_name(self) <span class="position">@ line 177</span></li></ul><ul id="m-_inverse_rrule"><li>_inverse_rrule(self) <span class="position">@ line 215</span></li></ul><details><summary id="m-_is_allday">_is_allday(self) <span class="position">@ line 563</span></summary><pre>Returns whether a majority of events are allday or not (there might be some outlier events)</pre></details><details><summary id="m-_range_calculation">_range_calculation(self, event, duration) <span class="position">@ line 476</span></summary><pre>Calculate the range of recurrence when applying the recurrence
The following issues are taken into account:
start of period is sometimes in the past (weekly or monthly rule).
We can easily filter these range values but then the count value may be wrong...
In that case, we just increase the count value, recompute the ranges and dismiss the useless values</pre></details><details><summary id="m-_reconcile_events">_reconcile_events(self, ranges) <span class="position">@ line 221</span></summary><pre>:param ranges: iterable of tuples (datetime_start, datetime_stop)
:return: tuple (events of the recurrence already in sync with ranges,
and ranges not covered by any events)</pre></details><details><summary id="m-_rrule_serialize">_rrule_serialize(self) <span class="position">@ line 380</span></summary><pre>Compute rule string according to value type RECUR of iCalendar
:return: string containing recurring rule (empty if no rule)</pre></details><details><summary id="m-_select_new_base_event">_select_new_base_event(self) <span class="position">@ line 235</span></summary><pre>when the base event is no more available (archived, deleted, etc.), a new one should be selected</pre></details><details><summary id="m-_setup_alarms">_setup_alarms(self, recurrence_update) <span class="position">@ line 283</span></summary><pre>Schedule cron triggers for future events
Create one ir.cron.trigger per recurrence.
:param recurrence_update: boolean: if true, update all recurrences in self, else only the recurrences
without trigger</pre></details><details><summary id="m-_split_from">_split_from(self, event, recurrence_values) <span class="position">@ line 314</span></summary><pre>Stops the current recurrence at the given event and creates a new one starting
with the event.
:param event: starting point of the new recurrence
:param recurrence_values: values applied to the new recurrence
:return: new recurrence</pre></details><details><summary id="m-_stop_at">_stop_at(self, event) <span class="position">@ line 338</span></summary><pre>Stops the recurrence at the given event. Detach the event and all following
events from the recurrence.

:return: detached events from the recurrence</pre></details><details><summary id="m-_write_events">_write_events(self, values, dtstart) <span class="position">@ line 371</span></summary><pre>Write values on events in the recurrence.
:param values: event values
:param dstart: if provided, only write events starting from this point in time</pre></details><ul id="m-get_recurrence_name"><li>get_recurrence_name(self) <span class="position">@ line 184</span></li></ul><h2>Inherited: odoo/addons/microsoft_calendar/models/calendar_recurrence_rule.py</h2><h3>Fields</h3><details><summary id="f-need_sync_m">need_sync_m <span class="position">@ line 14</span></summary><pre>need_sync_m = fields.Boolean(default=False)</pre></details><h3>Methods</h3><ul id="m-_apply_recurrence"><li>_apply_recurrence(self, specific_values_creation, no_send_edit, generic_values_creation) <span class="position">@ line 32</span></li></ul><ul id="m-_cancel_microsoft"><li>_cancel_microsoft(self) <span class="position">@ line 143</span></li></ul><ul id="m-_compute_rrule"><li>_compute_rrule(self) <span class="position">@ line 16</span></li></ul><ul id="m-_ensure_attendees_have_email"><li>_ensure_attendees_have_email(self) <span class="position">@ line 167</span></li></ul><details><summary id="m-_get_event_user_m">_get_event_user_m(self, user_id) <span class="position">@ line 186</span></summary><pre>Get the user who will send the request to Microsoft (organizer if synchronized and current user otherwise).</pre></details><ul id="m-_get_microsoft_sync_domain"><li>_get_microsoft_sync_domain(self) <span class="position">@ line 138</span></li></ul><ul id="m-_get_microsoft_synced_fields"><li>_get_microsoft_synced_fields(self) <span class="position">@ line 70</span></li></ul><ul id="m-_get_organizer"><li>_get_organizer(self) <span class="position">@ line 62</span></li></ul><ul id="m-_get_rrule"><li>_get_rrule(self, dtstart) <span class="position">@ line 65</span></li></ul><details><summary id="m-_has_base_event_time_fields_changed">_has_base_event_time_fields_changed(self, new) <span class="position">@ line 79</span></summary><pre>Indicates if at least one time field of the base event has changed, based
on provided `new` values.
Note: for all day event comparison, hours/minutes are ignored.</pre></details><ul id="m-_inverse_rrule"><li>_inverse_rrule(self) <span class="position">@ line 24</span></li></ul><details><summary id="m-_microsoft_values">_microsoft_values(self, fields_to_sync) <span class="position">@ line 160</span></summary><pre>Get values to update the whole Outlook event recurrence.
(done through the first event of the Outlook recurrence).</pre></details><details><summary id="m-_split_from">_split_from(self, event, recurrence_values) <span class="position">@ line 170</span></summary><pre>When a recurrence is splitted, the base event of the new recurrence already
exist and may be already synced with Outlook.
In this case, we need to be removed this event on Outlook side to avoid duplicates while posting
the new recurrence.</pre></details><ul id="m-_write_events"><li>_write_events(self, values, dtstart) <span class="position">@ line 56</span></li></ul><ul id="m-_write_from_microsoft"><li>_write_from_microsoft(self, microsoft_event, vals) <span class="position">@ line 97</span></li></ul><h2>Inherited: odoo/addons/google_calendar/models/calendar_recurrence_rule.py</h2><h3>Methods</h3><ul id="m-_apply_recurrence"><li>_apply_recurrence(self, specific_values_creation, no_send_edit, generic_values_creation) <span class="position">@ line 19</span></li></ul><ul id="m-_cancel"><li>_cancel(self) <span class="position">@ line 71</span></li></ul><ul id="m-_create_from_google"><li>_create_from_google(self, gevents, vals_list) <span class="position">@ line 163</span></li></ul><details><summary id="m-_get_event_google_id">_get_event_google_id(self, event) <span class="position">@ line 50</span></summary><pre>Return the Google id of recurring event.
Google ids of recurrence instances are formatted as: {recurrence google_id}_{UTC starting time in compacted ISO8601}</pre></details><ul id="m-_get_event_user"><li>_get_event_user(self) <span class="position">@ line 234</span></li></ul><ul id="m-_get_google_synced_fields"><li>_get_google_synced_fields(self) <span class="position">@ line 75</span></li></ul><ul id="m-_get_sync_domain"><li>_get_sync_domain(self) <span class="position">@ line 193</span></li></ul><ul id="m-_google_values"><li>_google_values(self) <span class="position">@ line 207</span></li></ul><ul id="m-_write_events"><li>_write_events(self, values, dtstart) <span class="position">@ line 65</span></li></ul><ul id="m-_write_from_google"><li>_write_from_google(self, gevent, vals) <span class="position">@ line 84</span></li></ul><script src="class.js"></script></body></html>
